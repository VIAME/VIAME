/* This file is part of VIAME, and is distributed under an OSI-approved *
 * BSD 3-Clause License. See either the root top-level LICENSE file or  *
 * https://github.com/VIAME/VIAME/blob/main/LICENSE.txt for details.    */

/**
 * \file
 * \brief Process query descriptors using IQR and AdaBoost ranking
 */

// Define _USE_MATH_DEFINES before cmath to get M_PI on Windows
#ifndef _USE_MATH_DEFINES
#define _USE_MATH_DEFINES
#endif

#include "process_query_process_adaboost.h"
#include "iqr_session_adaboost.h"

#include <vital/vital_types.h>
#include <vital/types/descriptor.h>
#include <vital/types/descriptor_set.h>
#include <vital/logger/logger.h>

#ifdef VIAME_ENABLE_CPPDB
#include <cppdb/frontend.h>
#endif

#include <fstream>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

namespace viame
{

using namespace viame::iqr;

// Port traits for this process
create_port_trait( positive_descriptor_set, descriptor_set,
  "Positive exemplar descriptor set" );
create_port_trait( positive_exemplar_uids, string_vector,
  "Positive exemplar descriptor UIDs" );
create_port_trait( negative_descriptor_set, descriptor_set,
  "Negative exemplar descriptor set" );
create_port_trait( negative_exemplar_uids, string_vector,
  "Negative exemplar descriptor UIDs" );
create_port_trait( iqr_positive_uids, string_vector,
  "Positive sample UIDs from IQR feedback" );
create_port_trait( iqr_negative_uids, string_vector,
  "Negative sample UIDs from IQR feedback" );
create_port_trait( iqr_query_model, uchar_vector,
  "Input AdaBoost model bytes for query" );
create_port_trait( result_uids, string_vector,
  "Result ranked descriptor UIDs in rank order" );
create_port_trait( result_scores, double_vector,
  "Result ranked descriptor scores in rank order" );
create_port_trait( feedback_uids, string_vector,
  "Feedback descriptor UIDs for active learning" );
create_port_trait( feedback_distances, double_vector,
  "Feedback descriptor distances from decision boundary" );
create_port_trait( feedback_scores, double_vector,
  "Feedback descriptor scores" );
create_port_trait( result_model, uchar_vector,
  "Trained AdaBoost model bytes" );

// Config traits - shared
create_config_trait( descriptor_index_file, std::string, "",
  "Path to the CSV file containing the searchable descriptor index (used if conn_str is empty)" );
create_config_trait( conn_str, std::string, "",
  "Database connection string (e.g., postgresql:host=localhost;user=postgres). "
  "If set, descriptors are loaded from the DESCRIPTOR table instead of CSV file." );
create_config_trait( pos_seed_neighbors, unsigned, "500",
  "Number of nearest neighbors to retrieve for each positive example" );
create_config_trait( query_return_size, unsigned, "500",
  "Number of ranked elements to return. 0 returns all." );
create_config_trait( nn_max_linear_search, unsigned, "50000",
  "Maximum number of descriptors for brute-force linear NN search. "
  "For larger indexes, approximate search with random sampling is used." );
create_config_trait( nn_sample_fraction, double, "0.1",
  "Fraction of index to sample when using approximate NN search (0.0-1.0). "
  "Only used when index size exceeds nn_max_linear_search." );
create_config_trait( autoneg_select_ratio, unsigned, "0",
  "Number of maximally distant descriptors to auto-select as negatives "
  "for each positive example when no negative examples are provided. "
  "Set to 0 (default) to disable auto-negatives. "
  "Set to 1+ to enable model training on the first query iteration." );
create_config_trait( autoneg_from_full_index, bool, "false",
  "When auto-selecting negatives, choose from the full descriptor index "
  "instead of just the working index (neighbors of positives). "
  "When false (default), negatives are selected from the working index only. "
  "When true, negatives are selected from all indexed descriptors." );

// LSH (Locality Sensitive Hashing) config traits for fast approximate NN search
create_config_trait( use_lsh_index, bool, "true",
  "Use LSH index for fast approximate nearest neighbor search. "
  "When enabled, requires ITQ model and hash code files. "
  "Falls back to brute-force if LSH files not found." );
create_config_trait( lsh_hash_codes_file, std::string, "database/ITQ/lsh_hash_codes.npy",
  "Path to numpy file containing LSH hash codes (uint8 array, N x bit_length). "
  "Generated by generate_nn_index.py." );
create_config_trait( lsh_hash_uids_file, std::string, "database/ITQ/lsh_hash_uids.txt",
  "Path to text file containing UIDs corresponding to hash codes (one per line). "
  "Generated by generate_nn_index.py." );
create_config_trait( itq_mean_vec_file, std::string, "database/ITQ/itq.model.b256_i100_r0.mean_vec.npy",
  "Path to numpy file containing ITQ mean vector for hash computation." );
create_config_trait( itq_rotation_file, std::string, "database/ITQ/itq.model.b256_i100_r0.rotation.npy",
  "Path to numpy file containing ITQ rotation matrix for hash computation." );
create_config_trait( lsh_bit_length, unsigned, "256",
  "Number of bits in LSH hash codes. Must match the trained ITQ model." );
create_config_trait( lsh_neighbor_multiplier, unsigned, "10",
  "Multiplier for LSH candidate retrieval. Retrieves k * multiplier candidates "
  "via hamming distance, then re-ranks with the configured distance method to get top k." );
create_config_trait( nn_distance_method, std::string, "euclidean",
  "Distance method for nearest neighbor re-ranking after LSH candidate retrieval. "
  "Options: 'euclidean', 'cosine', 'hik' (histogram intersection). "
  "Default is 'euclidean'." );
create_config_trait( force_exemplar_scores, bool, "true",
  "Force positive exemplars to score 1.0 and negative exemplars to score 0.0. "
  "When true (default), exemplar scores are overwritten after prediction. "
  "When false, exemplars receive their predicted scores." );
create_config_trait( scoring_norm, bool, "true",
  "Enforce L2 normalization of descriptors before computing Euclidean distance or hash codes. "
  "When true (default), descriptors are normalized. "
  "This is critical for Euclidean distance to rank similarly to Cosine similarity." );
create_config_trait( score_multiplier, double, "1.0",
  "Multiplier applied to the distance before converting to a similarity score. "
  "Used to tune the score distribution to match external baselines. Default 1.0." );

// Config traits - AdaBoost specific
create_config_trait( boost_type, std::string, "gentle",
  "AdaBoost type: discrete, real, logit, or gentle" );
create_config_trait( boost_weak_count, int, "100",
  "Number of weak classifiers (decision stumps) in the ensemble" );
create_config_trait( boost_max_depth, int, "1",
  "Maximum depth of each weak classifier tree. "
  "1 = decision stumps (default), higher = more complex weak learners." );
create_config_trait( boost_weight_trim_rate, double, "0.95",
  "Weight trimming rate for AdaBoost. "
  "Samples with weights below this percentile are excluded during training. "
  "0.0 disables trimming. Default 0.95." );

//--------------------------------------------------------------------------------
// Private implementation class
class process_query_process_adaboost::priv
{
public:
  priv()
    : m_descriptor_index_file( "" )
    , m_conn_str( "" )
    , m_pos_seed_neighbors( 500 )
    , m_query_return_size( 300 )
    , m_nn_max_linear_search( 50000 )
    , m_nn_sample_fraction( 0.1 )
    , m_autoneg_select_ratio( 0 )
    , m_autoneg_from_full_index( false )
    , m_use_lsh_index( true )
    , m_lsh_bit_length( 256 )
    , m_lsh_neighbor_multiplier( 10 )
    , m_force_exemplar_scores( true )
    , m_scoring_norm( true )
    , m_score_multiplier( 1.0 )
    , m_boost_type( "gentle" )
    , m_boost_weak_count( 100 )
    , m_boost_max_depth( 1 )
    , m_boost_weight_trim_rate( 0.95 )
    , m_index_loaded( false )
    , m_lsh_loaded( false )
    , m_iqr_session( nullptr )
    , m_logger( kwiver::vital::get_logger( "viame.opencv.process_query_adaboost" ) ) {}

  ~priv() {}

  std::string m_descriptor_index_file;
  std::string m_conn_str;
  unsigned m_pos_seed_neighbors;
  unsigned m_query_return_size;
  unsigned m_nn_max_linear_search;
  double m_nn_sample_fraction;
  unsigned m_autoneg_select_ratio;
  bool m_autoneg_from_full_index;

  // LSH configuration
  bool m_use_lsh_index;
  std::string m_lsh_hash_codes_file;
  std::string m_lsh_hash_uids_file;
  std::string m_itq_mean_vec_file;
  std::string m_itq_rotation_file;
  unsigned m_lsh_bit_length;
  unsigned m_lsh_neighbor_multiplier;
  std::string m_nn_distance_method;
  bool m_force_exemplar_scores;
  bool m_scoring_norm;
  double m_score_multiplier;

  // AdaBoost configuration
  std::string m_boost_type;
  int m_boost_weak_count;
  int m_boost_max_depth;
  double m_boost_weight_trim_rate;

  bool m_index_loaded;
  bool m_lsh_loaded;

  // Full descriptor index
  std::unordered_map< std::string, std::vector< double > > m_descriptor_index;

  // LSH index for fast approximate NN search
  lsh_index m_lsh_index;

  // IQR session
  std::unique_ptr< iqr_session_adaboost > m_iqr_session;

  kwiver::vital::logger_handle_t m_logger;

  void load_descriptor_index()
  {
#ifdef VIAME_ENABLE_CPPDB
    if( !m_conn_str.empty() )
    {
      load_descriptor_index_from_db();
      return;
    }
#endif

    load_descriptor_index_from_csv();
  }

  void load_descriptor_index_from_csv()
  {
    if( m_descriptor_index_file.empty() )
    {
      throw std::runtime_error(
        "Either descriptor_index_file or conn_str must be provided" );
    }

    std::ifstream file( m_descriptor_index_file );

    if( !file.is_open() )
    {
      throw std::runtime_error( "Failed to open descriptor index file: " +
        m_descriptor_index_file );
    }

    std::string line;
    while( std::getline( file, line ) )
    {
      if( line.empty() ) continue;

      std::istringstream ss( line );
      std::string uid;

      if( !std::getline( ss, uid, ',' ) ) continue;

      std::vector< double > values;
      std::string value_str;
      while( std::getline( ss, value_str, ',' ) )
      {
        try { values.push_back( std::stod( value_str ) ); }
        catch( const std::exception& ) {}
      }

      if( !values.empty() )
      {
        m_descriptor_index[uid] = std::move( values );
      }
    }

    m_index_loaded = true;
  }

#ifdef VIAME_ENABLE_CPPDB
  void load_descriptor_index_from_db()
  {
    ::cppdb::session conn( m_conn_str );

    // Query all descriptors from the DESCRIPTOR table
    ::cppdb::result res = conn.create_statement(
      "SELECT UID, VECTOR_DATA FROM DESCRIPTOR" ).query();

    while( res.next() )
    {
      std::string uid;
      std::string vector_data;

      res.fetch( 0, uid );
      res.fetch( 1, vector_data );

      // Parse PostgreSQL array format: {val1,val2,val3,...}
      if( !vector_data.empty() && vector_data.front() == '{' )
      {
        vector_data = vector_data.substr( 1 );
      }
      if( !vector_data.empty() && vector_data.back() == '}' )
      {
        vector_data.pop_back();
      }

      std::vector< double > values;
      std::istringstream ss( vector_data );
      std::string value_str;
      while( std::getline( ss, value_str, ',' ) )
      {
        try { values.push_back( std::stod( value_str ) ); }
        catch( const std::exception& ) {}
      }

      if( !values.empty() )
      {
        m_descriptor_index[uid] = std::move( values );
      }
    }

    conn.close();
    m_index_loaded = true;
  }
#endif
};

// ===============================================================================

process_query_process_adaboost
::process_query_process_adaboost( config_block_sptr const& config )
  : process( config ),
    d( new process_query_process_adaboost::priv() )
{
  make_ports();
  make_config();
}


process_query_process_adaboost
::~process_query_process_adaboost()
{
}


// -------------------------------------------------------------------------------
void
process_query_process_adaboost
::_configure()
{
  d->m_descriptor_index_file = config_value_using_trait( descriptor_index_file );
  d->m_conn_str = config_value_using_trait( conn_str );
  d->m_pos_seed_neighbors = config_value_using_trait( pos_seed_neighbors );
  d->m_query_return_size = config_value_using_trait( query_return_size );
  d->m_nn_max_linear_search = config_value_using_trait( nn_max_linear_search );
  d->m_nn_sample_fraction = config_value_using_trait( nn_sample_fraction );
  d->m_autoneg_select_ratio = config_value_using_trait( autoneg_select_ratio );
  d->m_autoneg_from_full_index = config_value_using_trait( autoneg_from_full_index );

  // LSH configuration
  d->m_use_lsh_index = config_value_using_trait( use_lsh_index );
  d->m_lsh_hash_codes_file = config_value_using_trait( lsh_hash_codes_file );
  d->m_lsh_hash_uids_file = config_value_using_trait( lsh_hash_uids_file );
  d->m_itq_mean_vec_file = config_value_using_trait( itq_mean_vec_file );
  d->m_itq_rotation_file = config_value_using_trait( itq_rotation_file );
  d->m_lsh_bit_length = config_value_using_trait( lsh_bit_length );
  d->m_lsh_neighbor_multiplier = config_value_using_trait( lsh_neighbor_multiplier );
  d->m_nn_distance_method = config_value_using_trait( nn_distance_method );
  d->m_force_exemplar_scores = config_value_using_trait( force_exemplar_scores );
  d->m_scoring_norm = config_value_using_trait( scoring_norm );
  d->m_score_multiplier = config_value_using_trait( score_multiplier );

  // AdaBoost configuration
  d->m_boost_type = config_value_using_trait( boost_type );
  d->m_boost_weak_count = config_value_using_trait( boost_weak_count );
  d->m_boost_max_depth = config_value_using_trait( boost_max_depth );
  d->m_boost_weight_trim_rate = config_value_using_trait( boost_weight_trim_rate );

  d->load_descriptor_index();

  // Try to load LSH index if enabled
  d->m_lsh_loaded = false;
  if( d->m_use_lsh_index )
  {
    d->m_lsh_loaded = d->m_lsh_index.load(
      d->m_lsh_hash_codes_file,
      d->m_lsh_hash_uids_file,
      d->m_itq_mean_vec_file,
      d->m_itq_rotation_file,
      d->m_lsh_bit_length );

    if( d->m_lsh_loaded )
    {
      LOG_INFO( d->m_logger, "Loaded LSH index with "
        << d->m_lsh_index.size() << " descriptors ("
        << d->m_lsh_bit_length << " bits)" );
    }
    else
    {
      throw std::runtime_error(
        "Failed to load LSH index. use_lsh_index is enabled but required files "
        "are missing or invalid. Check that the following files exist:\n"
        "  - " + d->m_lsh_hash_codes_file + "\n"
        "  - " + d->m_lsh_hash_uids_file + "\n"
        "  - " + d->m_itq_mean_vec_file + "\n"
        "  - " + d->m_itq_rotation_file + "\n"
        "These files are generated by generate_nn_index.py."
        "Set use_lsh_index to false to use brute-force NN search instead." );
    }
  }

  // Create IQR session
  d->m_iqr_session = std::make_unique< iqr_session_adaboost >( d->m_pos_seed_neighbors );
  d->m_iqr_session->set_boost_type( d->m_boost_type );
  d->m_iqr_session->set_weak_count( d->m_boost_weak_count );
  d->m_iqr_session->set_max_depth( d->m_boost_max_depth );
  d->m_iqr_session->set_weight_trim_rate( d->m_boost_weight_trim_rate );
  d->m_iqr_session->set_nn_max_linear_search( d->m_nn_max_linear_search );
  d->m_iqr_session->set_nn_sample_fraction( d->m_nn_sample_fraction );
  d->m_iqr_session->set_autoneg_select_ratio( d->m_autoneg_select_ratio );
  d->m_iqr_session->set_autoneg_from_full_index( d->m_autoneg_from_full_index );
  d->m_iqr_session->set_full_index_ref( &d->m_descriptor_index );

  // Set LSH index reference if loaded
  if( d->m_lsh_loaded )
  {
    d->m_iqr_session->set_lsh_index_ref( &d->m_lsh_index );
    d->m_iqr_session->set_lsh_neighbor_multiplier( d->m_lsh_neighbor_multiplier );
  }
  d->m_iqr_session->set_nn_distance_method( d->m_nn_distance_method );
  d->m_iqr_session->set_force_exemplar_scores( d->m_force_exemplar_scores );
  d->m_iqr_session->set_scoring_norm( d->m_scoring_norm );
  d->m_iqr_session->set_score_multiplier( d->m_score_multiplier );
}


// -------------------------------------------------------------------------------
void
process_query_process_adaboost
::_step()
{
  // Grab inputs
  kwiver::vital::descriptor_set_sptr pos_desc_set =
    grab_from_port_using_trait( positive_descriptor_set );
  kwiver::vital::string_vector_sptr pos_uids =
    grab_from_port_using_trait( positive_exemplar_uids );
  kwiver::vital::descriptor_set_sptr neg_desc_set =
    grab_from_port_using_trait( negative_descriptor_set );
  kwiver::vital::string_vector_sptr neg_uids =
    grab_from_port_using_trait( negative_exemplar_uids );
  kwiver::vital::string_vector_sptr iqr_pos_uids =
    grab_from_port_using_trait( iqr_positive_uids );
  kwiver::vital::string_vector_sptr iqr_neg_uids =
    grab_from_port_using_trait( iqr_negative_uids );
  kwiver::vital::uchar_vector_sptr iqr_model =
    grab_from_port_using_trait( iqr_query_model );

  // Reset IQR session if no feedback (new query)
  if( iqr_pos_uids->empty() && iqr_neg_uids->empty() )
  {
    d->m_iqr_session->reset();
  }

  // Load model from bytes if provided
  if( iqr_model && !iqr_model->empty() )
  {
    d->m_iqr_session->load_model_from_bytes( *iqr_model );
  }

  // Collect positive descriptors from input set
  std::vector< descriptor_element > user_pos_elements;
  {
    auto descriptors = pos_desc_set->descriptors();
    for( size_t i = 0; i < descriptors.size() && i < pos_uids->size(); ++i )
    {
      user_pos_elements.emplace_back( (*pos_uids)[i], descriptors[i]->as_double() );
    }
  }

  // Collect negative descriptors from input set
  std::vector< descriptor_element > user_neg_elements;
  {
    auto descriptors = neg_desc_set->descriptors();
    for( size_t i = 0; i < descriptors.size() && i < neg_uids->size(); ++i )
    {
      user_neg_elements.emplace_back( (*neg_uids)[i], descriptors[i]->as_double() );
    }
  }

  // Collect positive descriptors from IQR feedback UIDs
  std::vector< descriptor_element > iqr_pos_elements;
  for( const std::string& uid : *iqr_pos_uids )
  {
    auto it = d->m_descriptor_index.find( uid );
    if( it != d->m_descriptor_index.end() )
    {
      iqr_pos_elements.emplace_back( uid, it->second );
    }
  }

  // Collect negative descriptors from IQR feedback UIDs
  std::vector< descriptor_element > iqr_neg_elements;
  for( const std::string& uid : *iqr_neg_uids )
  {
    auto it = d->m_descriptor_index.find( uid );
    if( it != d->m_descriptor_index.end() )
    {
      iqr_neg_elements.emplace_back( uid, it->second );
    }
  }

  // Log IQR feedback resolution
  {
    LOG_INFO( d->m_logger, "IQR feedback: "
      << iqr_pos_uids->size() << " positive UIDs received, "
      << iqr_pos_elements.size() << " resolved; "
      << iqr_neg_uids->size() << " negative UIDs received, "
      << iqr_neg_elements.size() << " resolved" );

    if( iqr_pos_elements.size() < iqr_pos_uids->size() )
    {
      size_t n_failed = iqr_pos_uids->size() - iqr_pos_elements.size();
      LOG_WARN( d->m_logger, n_failed
        << " positive IQR UIDs failed to resolve in descriptor index" );
    }
    if( iqr_neg_elements.size() < iqr_neg_uids->size() )
    {
      size_t n_failed = iqr_neg_uids->size() - iqr_neg_elements.size();
      LOG_WARN( d->m_logger, n_failed
        << " negative IQR UIDs failed to resolve in descriptor index" );
    }

    LOG_INFO( d->m_logger, "User-provided: "
      << user_pos_elements.size() << " positives, "
      << user_neg_elements.size() << " negatives" );
  }

  // Adjudicate with user-provided examples
  d->m_iqr_session->adjudicate( user_pos_elements, user_neg_elements );

  // Adjudicate with IQR feedback
  d->m_iqr_session->adjudicate( iqr_pos_elements, iqr_neg_elements );

  LOG_INFO( d->m_logger, "Session after adjudication: "
    << d->m_iqr_session->num_positives() << " total positives, "
    << d->m_iqr_session->num_negatives() << " total negatives" );

  // Update working index with nearest neighbors
  d->m_iqr_session->update_working_index( d->m_descriptor_index );

  // Train AdaBoost and refine
  bool model_trained = d->m_iqr_session->refine();

  LOG_INFO( d->m_logger, "AdaBoost refine result: "
    << ( model_trained ? "model trained" : "no model (skipped or failed)" ) );

  // Get ordered results
  auto ordered_results = d->m_iqr_session->ordered_results();

  // Get feedback descriptors
  auto ordered_feedback = d->m_iqr_session->ordered_feedback();

  // Limit results if configured
  if( d->m_query_return_size > 0 )
  {
    if( ordered_results.size() > d->m_query_return_size )
    {
      ordered_results.resize( d->m_query_return_size );
    }
    if( ordered_feedback.size() > d->m_query_return_size )
    {
      ordered_feedback.resize( d->m_query_return_size );
    }
  }

  // Build output vectors
  auto result_uids_vec = std::make_shared< kwiver::vital::string_vector >();
  auto result_scores_vec = std::make_shared< kwiver::vital::double_vector >();
  auto feedback_uids_vec = std::make_shared< kwiver::vital::string_vector >();
  auto feedback_dists_vec = std::make_shared< kwiver::vital::double_vector >();
  auto feedback_scores_vec = std::make_shared< kwiver::vital::double_vector >();

  for( const auto& r : ordered_results )
  {
    result_uids_vec->push_back( r.first );
    result_scores_vec->push_back( r.second );
  }

  // Compute feedback scores as linear interpolation from 1 to 0
  double n_feedback = static_cast< double >( ordered_feedback.size() );
  for( size_t i = 0; i < ordered_feedback.size(); ++i )
  {
    feedback_uids_vec->push_back( ordered_feedback[i].first );
    feedback_dists_vec->push_back( ordered_feedback[i].second );
    feedback_scores_vec->push_back( n_feedback > 1 ?
      1.0 - static_cast< double >( i ) / ( n_feedback - 1.0 ) : 1.0 );
  }

  // Get model bytes
  auto model_bytes = d->m_iqr_session->get_model_bytes();
  auto result_model_vec = std::make_shared< kwiver::vital::uchar_vector >(
    model_bytes.begin(), model_bytes.end() );

  // Push outputs
  push_to_port_using_trait( result_uids, result_uids_vec );
  push_to_port_using_trait( result_scores, result_scores_vec );
  push_to_port_using_trait( feedback_uids, feedback_uids_vec );
  push_to_port_using_trait( feedback_distances, feedback_dists_vec );
  push_to_port_using_trait( feedback_scores, feedback_scores_vec );
  push_to_port_using_trait( result_model, result_model_vec );
}


// -------------------------------------------------------------------------------
void
process_query_process_adaboost
::make_ports()
{
  sprokit::process::port_flags_t optional;

  sprokit::process::port_flags_t required;
  required.insert( flag_required );

  // -- inputs --
  declare_input_port_using_trait( positive_descriptor_set, required );
  declare_input_port_using_trait( positive_exemplar_uids, required );
  declare_input_port_using_trait( negative_descriptor_set, optional );
  declare_input_port_using_trait( negative_exemplar_uids, optional );
  declare_input_port_using_trait( iqr_positive_uids, optional );
  declare_input_port_using_trait( iqr_negative_uids, optional );
  declare_input_port_using_trait( iqr_query_model, optional );

  // -- outputs --
  declare_output_port_using_trait( result_uids, optional );
  declare_output_port_using_trait( result_scores, optional );
  declare_output_port_using_trait( feedback_uids, optional );
  declare_output_port_using_trait( feedback_distances, optional );
  declare_output_port_using_trait( feedback_scores, optional );
  declare_output_port_using_trait( result_model, optional );
}


// -------------------------------------------------------------------------------
void
process_query_process_adaboost
::make_config()
{
  declare_config_using_trait( descriptor_index_file );
  declare_config_using_trait( conn_str );
  declare_config_using_trait( pos_seed_neighbors );
  declare_config_using_trait( query_return_size );
  declare_config_using_trait( nn_max_linear_search );
  declare_config_using_trait( nn_sample_fraction );
  declare_config_using_trait( autoneg_select_ratio );
  declare_config_using_trait( autoneg_from_full_index );

  // LSH configuration
  declare_config_using_trait( use_lsh_index );
  declare_config_using_trait( lsh_hash_codes_file );
  declare_config_using_trait( lsh_hash_uids_file );
  declare_config_using_trait( itq_mean_vec_file );
  declare_config_using_trait( itq_rotation_file );
  declare_config_using_trait( lsh_bit_length );
  declare_config_using_trait( lsh_neighbor_multiplier );
  declare_config_using_trait( nn_distance_method );
  declare_config_using_trait( force_exemplar_scores );
  declare_config_using_trait( scoring_norm );
  declare_config_using_trait( score_multiplier );

  // AdaBoost configuration
  declare_config_using_trait( boost_type );
  declare_config_using_trait( boost_weak_count );
  declare_config_using_trait( boost_max_depth );
  declare_config_using_trait( boost_weight_trim_rate );
}

} // end namespace viame
