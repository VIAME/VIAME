# =============================================================================
# Title: Interactive Stereo Service Configuration - Template Matching / OpenCV
#
# Description: KWIVER flat config for the interactive stereo annotation service.
# Used by python -m viame.core.interactive_stereo for interactive disparity
# computation in DIVE stereo annotation mode.
#
# This configuration uses non-machine-learning methods for stereo matching:
# - OpenCV's Semi-Global Block Matching (SGBM) algorithm for dense disparity
# - Block-based template matching approach (SGBM uses normalized cross-correlation
#   style matching within its cost aggregation)
#
# SGBM is a classical computer vision algorithm that uses block matching
# (similar to template matching) with semi-global optimization for smooth
# disparity maps. It does not require GPU or neural network inference.
# =============================================================================

# Stereo depth/disparity algorithm - using OpenCV SGBM (non-ML)
compute_stereo_depth_map:type = ocv_stereo_disparity

# OpenCV stereo disparity settings
# Algorithm: "BM" (Block Matching) or "SGBM" (Semi-Global Block Matching)
# SGBM generally produces better results but is slightly slower
compute_stereo_depth_map:ocv_stereo_disparity:algorithm = SGBM

# Minimum possible disparity value. Normally 0, but can be negative for
# cameras with convergent optical axes.
compute_stereo_depth_map:ocv_stereo_disparity:min_disparity = 0

# Maximum disparity minus minimum disparity. Must be divisible by 16.
# Larger values allow matching objects closer to the camera.
# 256 provides good range for typical stereo setups.
compute_stereo_depth_map:ocv_stereo_disparity:num_disparities = 256

# SAD (Sum of Absolute Differences) window size for BM algorithm. Must be odd.
# Larger values produce smoother results but may miss fine details.
compute_stereo_depth_map:ocv_stereo_disparity:sad_window_size = 21

# Block size for SGBM algorithm. Must be odd, typically 3-11.
# Smaller values preserve more detail, larger values are more robust to noise.
compute_stereo_depth_map:ocv_stereo_disparity:block_size = 5

# Speckle filtering parameters - removes small isolated disparity regions
compute_stereo_depth_map:ocv_stereo_disparity:speckle_window_size = 100
compute_stereo_depth_map:ocv_stereo_disparity:speckle_range = 32

# Output format: "uint16_scaled" produces disparity * 256 as uint16
# This is compatible with the interactive stereo service
compute_stereo_depth_map:ocv_stereo_disparity:output_format = uint16_scaled

# WLS (Weighted Least Squares) filtering - smooths disparity while preserving edges
# Enable for cleaner results at the cost of some processing time
compute_stereo_depth_map:ocv_stereo_disparity:use_wls_filter = true
compute_stereo_depth_map:ocv_stereo_disparity:wls_lambda = 8000.0
compute_stereo_depth_map:ocv_stereo_disparity:wls_sigma = 1.5

# Service settings
service:scale = 1.0
