"""
ckwg +31
Copyright 2015-2016 by Kitware, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither name of Kitware, Inc. nor the names of any contributors may be used
   to endorse or promote products derived from this software without specific
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

==============================================================================

Interface to vital::camera class.

"""
import ctypes

import numpy

from vital.types import (
    CameraIntrinsics,
    Covariance,
    EigenArray,
    Rotation,
)
from vital.util import VitalObject, VitalErrorHandle


class Camera (VitalObject):
    """ vital::camera interface class """

    @classmethod
    def from_krtd_file(cls, filepath):
        """
        :return: New Camera instance from a KRTD format file
        :rtype: Camera
        """
        cam_read_krtd = cls.VITAL_LIB.vital_camera_read_krtd_file
        cam_read_krtd.argtypes = [ctypes.c_char_p, VitalErrorHandle.C_TYPE_PTR]
        cam_read_krtd.restype = cls.C_TYPE_PTR

        with VitalErrorHandle() as eh:
            return Camera(from_cptr=cam_read_krtd(filepath, eh))

    @classmethod
    def from_string(cls, s):
        """
        :param s: String camera representation. This must be in the same form
            that would be generated by this class' ``as_string`` method.
        :type s: str
        :return: New camera instance from a string sequence.
        :rtype: Camera
        """
        cam_from_str = cls.VITAL_LIB['vital_camera_new_from_string']
        cam_from_str.argtypes = [ctypes.c_char_p, VitalErrorHandle.c_ptr_type()]
        cam_from_str.restype = cls.c_ptr_type()
        with VitalErrorHandle() as eh:
            cptr = cam_from_str(s, eh)
        return Camera(from_cptr=cptr)

    def __init__(self, center=None, rotation=None, intrinsics=None,
                 from_cptr=None):
        """
        Create a new camera instance.

        :param center: Optional center to initialize to. Default is (0, 0, 0).
        :type center: EigenArray

        :param rotation: Optional rotation to initialize to. Otherwise the
            identity rotation is used.
        :type rotation: Rotation

        :param intrinsics: Optional intrinsics to initialize to. Otherwise the
            default intrinsics are used.
        :type intrinsics: CameraIntrinsics

        :param from_cptr: Existing C opaque instance pointer to use, preventing
            new instance construction. This should of course be a valid pointer
            to an instance. Only a new instance pointer or a new shared pointer
            reference should be passed here, otherwise memory issue will ensue.
            Thus this should only be used if you know what you're doing.

        """
        super(Camera, self).__init__(from_cptr, center, rotation, intrinsics)

    def _new(self, center, rotation, intrinsics):
        cam_new = self.VITAL_LIB['vital_camera_new']
        cam_new.argtypes = [EigenArray.c_ptr_type(3, 1, ctypes.c_double),
                            Rotation.c_ptr_type(ctypes.c_double),
                            CameraIntrinsics.c_ptr_type(),
                            VitalErrorHandle.c_ptr_type()]
        cam_new.restype = self.c_ptr_type()

        # Fill in parameter gaps
        if center is None:
            center = EigenArray(3)
            center[:] = 0
        else:
            center = EigenArray.from_iterable(center)

        if rotation is None:
            rotation = Rotation()

        if intrinsics is None:
            intrinsics = CameraIntrinsics()

        with VitalErrorHandle() as eh:
            return cam_new(center, rotation, intrinsics, eh)

    def _destroy(self):
        """ Delete instance through C API """
        if self._inst_ptr:
            cam_del = self.VITAL_LIB.vital_camera_destroy
            cam_del.argtypes = [self.C_TYPE_PTR, VitalErrorHandle.C_TYPE_PTR]

            with VitalErrorHandle() as eh:
                cam_del(self, eh)

    @property
    def center(self):
        """
        :return: a copy of this camera's center coordinate.
        :rtype: EigenArray
        """
        cam_center = self.VITAL_LIB['vital_camera_center']
        cam_center.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_center.restype = EigenArray.c_ptr_type(3)
        with VitalErrorHandle() as eh:
            c_ptr = cam_center(self, eh)
        return EigenArray(3, from_cptr=c_ptr)

    @property
    def translation(self):
        """
        :return: a copy of this camera's translation vector
        :rtype: EigenArray
        """
        cam_trans = self.VITAL_LIB['vital_camera_translation']
        cam_trans.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_trans.restype = EigenArray.c_ptr_type(3)
        with VitalErrorHandle() as eh:
            c_ptr = cam_trans(self, eh)
        return EigenArray(3, from_cptr=c_ptr)

    @property
    def covariance(self):
        """
        :return: a copy of this camera's center covariance
        :rtype: Covariance
        """
        cam_covar = self.VITAL_LIB['vital_camera_center_covar']
        cam_covar.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_covar.restype = Covariance.c_ptr_type(3)
        with VitalErrorHandle() as eh:
            c_ptr = cam_covar(self, eh)
        return Covariance(3, from_cptr=c_ptr)

    @property
    def rotation(self):
        """
        :return: a copy of this camera's rotation
        :rtype: Rotation
        """
        cam_rot = self.VITAL_LIB['vital_camera_rotation']
        cam_rot.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_rot.restype = Rotation.c_ptr_type()
        with VitalErrorHandle() as eh:
            c_ptr = cam_rot(self, eh)
        return Rotation(from_cptr=c_ptr)

    @property
    def intrinsics(self):
        """
        :return: a reference to this camera's intrinsics object
        :rtype: CameraIntrinsics
        """
        cam_int = self.VITAL_LIB['vital_camera_intrinsics']
        cam_int.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_int.restype = CameraIntrinsics.c_ptr_type()
        with VitalErrorHandle() as eh:
            c_ptr = cam_int(self, eh)
        return CameraIntrinsics(from_cptr=c_ptr)

    def __eq__(self, other):
        if isinstance(other, Camera):
            return (
                numpy.allclose(self.center, other.center) and
                numpy.allclose(self.translation, other.translation) and
                self.covariance == other.covariance and
                self.rotation == other.rotation and
                self.intrinsics == other.intrinsics
            )
        return False

    def __ne__(self, other):
        return not (self == other)

    def as_matrix(self):
        """
        Convert camera into a new 3x4 homogeneous projection matrix.

        :return: new 3x4 homogeneous projection matrix
        :rtype: EigenArray
        """
        cam_asmat = self.VITAL_LIB['vital_camera_as_matrix']
        cam_asmat.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]
        cam_asmat.restype = EigenArray.c_ptr_type(3, 4)
        with VitalErrorHandle() as eh:
            cptr = cam_asmat(self, eh)
        return EigenArray(3, 4, from_cptr=cptr)

    def as_string(self):
        """
        Convert the camera to a string representation

        :return: String representation of this camera
        :rtype: str
        """
        cam_tostr = self.VITAL_LIB['vital_camera_to_string']
        cam_tostr.argtypes = [self.c_ptr_type(), VitalErrorHandle.c_ptr_type()]

        cam_tostr.restype = ctypes.c_void_p
        with VitalErrorHandle() as eh:
            v_ptr = cam_tostr(self, eh)
        s = ctypes.c_char_p(v_ptr).value

        ptr_free = self.VITAL_LIB['vital_free_pointer']
        ptr_free.argtypes = [ctypes.c_void_p]
        ptr_free(v_ptr)

        return s

    def write_krtd_file(self, filepath):
        """
        Write camera object in KRTD format to the specified file.

        :param filepath: Path to the file to write to.
        :type filepath: str

        """
        cam_write_krtd = self.VITAL_LIB.vital_camera_write_krtd_file
        cam_write_krtd.argtypes = [self.C_TYPE_PTR, ctypes.c_char_p,
                                   VitalErrorHandle.C_TYPE_PTR]

        with VitalErrorHandle() as eh:
            cam_write_krtd(self, filepath, eh)

    def project(self, point):
        """
        Project a 3D point into a new 2D image point (eigen array) via this
        camera model.

        :param point: 3D point to transform into the 2D image plane.
        :return: New 2D eigen array that is the transformed point.
        """
        point = EigenArray.from_iterable(point, target_shape=(3, 1))

        cam_project = self.VITAL_LIB['vital_camera_project']
        cam_project.argtypes = [self.c_ptr_type(),
                                EigenArray.c_ptr_type(3),
                                VitalErrorHandle.c_ptr_type()]
        cam_project.restype = EigenArray.c_ptr_type(2)
        with VitalErrorHandle() as eh:
            cptr = cam_project(self, point, eh)
        return EigenArray(2, from_cptr=cptr)

    def depth(self, point):
        """
        Compute the distance of the 3d point to the image plane.

        Points with negative depth are behind the camera.

        :param point: 3D point to find the depth of.

        :return: Depth value
        :rtype: float

        """
        point = EigenArray.from_iterable(point)

        cam_depth = self.VITAL_LIB['vital_camera_depth']
        cam_depth.argtypes = [self.c_ptr_type(),
                              EigenArray.c_ptr_type(3),
                              VitalErrorHandle.c_ptr_type()]
        cam_depth.restype = ctypes.c_double
        with VitalErrorHandle() as eh:
            return cam_depth(self, point, eh)
